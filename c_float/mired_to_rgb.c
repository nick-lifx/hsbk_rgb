// generated by ../prepare/mired_to_rgb_gen_c_float.py

// Copyright (c) 2020 Nick Downing
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

#include <assert.h>
#include "mired_to_rgb.h"

#define RGB_RED 0
#define RGB_GREEN 1
#define RGB_BLUE 2
#define N_RGB 3

#define EPSILON 1e-6

void mired_to_rgb(float mired, float *rgb) {
  // validate inputs, allowing a little slack
  assert(mired >= 6.66666667e+01f * (1.f - EPSILON) && mired < 1.00000000e+03f * (1.f + EPSILON));

  // calculate red channel
  float r;
  if (mired < 1.53011240e+02f) {
    r = 4.07596973e-09f;
    r = r * mired + 8.77453520e-06f;
    r = r * mired + 1.29150846e-03f;
    r = r * mired + 5.82349796e-01f;
  }
  else {
    r = 1.00000000e+00f;
  }
  rgb[RGB_RED] = r;

  // calculate green channel
  float g;
  if (mired < 1.53280141e+02f) {
    g = -3.17889899e-09f;
    g = g * mired + 5.61670932e-06f;
    g = g * mired + 1.07304508e-03f;
    g = g * mired + 6.91397435e-01f;
  }
  else {
    g = -3.20617210e-15f;
    g = g * mired + 8.31774662e-12f;
    g = g * mired - 8.89633022e-09f;
    g = g * mired + 5.44440998e-06f;
    g = g * mired - 2.88743112e-03f;
    g = g * mired + 1.31877787e+00f;
  }
  rgb[RGB_GREEN] = g;

  // calculate blue channel
  float b;
  if (mired < 1.52991521e+02f) {
    b = 1.00000000e+00f;
  }
  else if (mired < 5.26548709e+02f) {
    b = 4.35983263e-18f;
    b = b * mired - 1.20261371e-14f;
    b = b * mired + 1.34307620e-11f;
    b = b * mired - 7.92676692e-09f;
    b = b * mired + 2.67076921e-06f;
    b = b * mired - 5.07643250e-04f;
    b = b * mired + 4.61903799e-02f;
    b = b * mired - 3.85926456e-01f;
  }
  else {
    b = 0.00000000e+00f;
  }
  rgb[RGB_BLUE] = b;
}

#ifdef STANDALONE
#include <stdlib.h>
#include <stdio.h>

int main(int argc, char **argv) {
  if (argc < 2) {
    printf(
      "usage: %s mired\n"
        "mired = colour temperature in micro reciprocal degrees Kelvin\n",
      argv[0]
    );
    exit(EXIT_FAILURE);
  }
  float mired = atof(argv[1]);

  float rgb[N_RGB];
  mired_to_rgb(mired, rgb);
  printf(
    "mired %.3f -> RGB (%.6f, %.6f, %.6f)\n",
    mired,
    rgb[RGB_RED],
    rgb[RGB_GREEN],
    rgb[RGB_BLUE]
  );

  return EXIT_SUCCESS;
}
#endif
